---
layout: post
title:  "第5章 初始化与清理"
date:   2017-06-05 15:14:54
categories: 《Java编程思想》
tags: Java 初始化与清理
author: M.renard
mathjax: false
---

* content
{:toc}

## 5.1 用构造器确保初始化

通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。

**构造器采用与类相同的名称。**

构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void)明显不同。





## 5.2 方法重载

如果有两个方法的方法名相同，但参数不一致，哪么可以说一个方法是另一个方法的重载。 

### 5.2.1 区分重载方法

* 方法的参数类型，个数顺序至少有一项不同
* 方法的返回类型可以不相同
* 方法的修饰符可以不相同

### 5.2.2 涉及基本类型的重载

常数会被当做int值处理。如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

方法接受较小的基本类型作为参数。如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。

## 5.3 默认构造器

默认构造器（又名“无参”构造器）是没有形式参数的——它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。

**如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器**

## 5.4 this关键字

this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this,直接调用即可。

**除构造器之外，编译器禁止在其他任何方法中调用构造器。**

static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来倒是可以的。

this的用法比较多和琐碎，书中只介绍了一点，详细的内容参见Java那些事中对this的介绍。

## 5.5 清理：终结处理和垃圾回收

Java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize(),就能在垃圾回收时刻做一些 重要的清理工作。

Java里的对象并非总是被垃圾回收，或者换句话说：

1. 对象可能不被垃圾回收。
2. 垃圾回收并不等于“析构”。
3. 垃圾回收只与内存有关。

### 5.5.1 垃圾回收器如何工作

垃圾回收器对于提高对象的创建速度，具有明显的效果。（很神奇……）

当垃圾回收器工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近“类似于栈一样”的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现了一种髙速的、有无限空间可供分配的堆模型。

垃圾回收器并非基于引用记数技术。它们依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有 “活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用, 如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。你所访问过的对象必须都是“活”的。注意，这就解决了“交互自引用的对象组”的问题——这种现象根本不会被发现，因此也就被自动回收了。

Java虚拟机将采用一种自适应的垃圾回收技术。有一种做法名为停止-复制（stop-and-copy)。这意味着，先暂停程序的运行（所以它不属于后台回收模式)，然后将所有存活的对象从当前堆复制到 另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨一个的，所以新堆保持紧凑排列。

对于这种所谓的“复制式回收器”而言，效率会降低。

首先，得有两个堆，某些Java虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。其次，当程序进入稳定状态后，可能只产生少量垃圾甚至没有垃圾，如果依然所有内存都复制一遍，就会很浪费。

为了避免这种情形，一些Java虚拟机会进行检査：要是没有新垃圾产生，就会转换到另一种工作模式（即“自适应”）。这种模式称为标记-清扫（mark-and-sweep)。“标记-清扫”所依据的思路是每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。

## 5.6 成员初始化

Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，java以编译时错误的形式来贯彻这种保证。而类的成员变量保证都会有一个初始值。

### 5.6.1 指定初始化

最简单的办法就是在定义成员变量的地方为其赋值。甚至可以通过调用某个方法来提供初值：

```java
public class MethodInit {
  int i = f();
  int f() { return 11; }
}
```

这个方法也可以带有参数，但这些参数必须是已经被初始化了的。

```java
public class MethodInit2 {
  int i = f();
  int j = g(i);
  int f() { return 11; }
  int g(int n) { return n * 10; }
}
```

但像下面这样写就不对了：

```java
public class MethodInit3 {
  //! int j = g(i); // Illegal forward reference
  int i = f();
  int f() { return 11; }
  int g(int n) { return n * 10; }
}
```

正确性取决于初始化的顺序，而与其编译方式无关。“向前引用”会被编译器警告。

## 5.7 构造器初始化

可以用构造器来进行初始化。这为编程带来了更大的灵活性。但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。

```java
public class Counter {
  int i;
  Counter() { i = 7; }
  // ...
}
```

i首先会被置0,然后变成7。对于所有基本类型和对象引用，包括在定义时已经指定初值的变量，这种倩况都是成立的；

### 5.7.1 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。

### 5.7.2 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量, 因此它只能作用于域。

静态初始化只有在必要时刻才会进行。初始化的顺序是**先静态对象（如果它们尚未因前面的对象创建过程而被初始化），而后是 “非静态”对象。**

假设有个名为Dog的类：

1. 即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须査找类路径，以定位Dog.class文件。
2. 然后载入Dog.class，这将创建一个Class对象，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
3. 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
4. 这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值 (对数字来说就是0,对布尔型和字符型也相同），而引用则被设置成了null。
5. 执行所有出现于字段定义处的初始化动作。
6. 执行构造器

### 5.7.3 显式的静态初始化

Java允许将多个静态初始化动作组织成一个特殊的“静态块”。

```java
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}
```

与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象)。

### 5.7.4 非静态实例初始化

Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：

```java
public class Mugs {
  Mug mug1;
  {
    mug1 = new Mug(1);
    print("mug1 & mug2 initialized");
  }
}
```

这种语法对于支持“匿名内部类”的初始化是必须的，**实例初始化子句是在两个构造器之前执行的。**

## 5.8 数组初始化

数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符[]来定义和使用的。要定义一个数组，只需在类型名后加上一对空方括号即可。

```java
int[] a;
```

方括号也可以置于标识符后面，不过前一种更合理一些。

```java
int a[];
```

编译器不允许指定数组的大小。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以使用一种特殊的初始化表达式，**它必须在创建数组的地方出现。**这种特殊的初始化是由一对花括号括起来的值组成的。在这种情况下，存储空间的分配（等价干使用new)将由编译器负责。

在Java中可以将一个数组赋值给另一个数组，其实真正做的只是复制了一个引用，一定要小心在这里犯错。

所有数组都有一个固有成员length。Java数组计 数也是从第0个元素开始，所以能使用的最大下标数是length-1。

数组元素中的基本数据类型值会自动初始化成空值。

也可以用花括号括起来的列表来初始化对象数组。

```java
public class ArrayInit {
  public static void main(String[] args) {
    Integer[] a = {
      new Integer(1),
      new Integer(2),
      3, // Autoboxing
    };
    Integer[] b = new Integer[]{
      new Integer(1),
      new Integer(2),
      3, // Autoboxing
    };
    System.out.println(Arrays.toString(a));
    System.out.println(Arrays.toString(b));
  }
} /* Output:
[1, 2, 3]
[1, 2, 3]
*/
```

在这两种形式中，初始化列表的最后一个逗号都是可选的（这一特性使维护长列表变得更容易)。

第一种形式只能用于数组被定义之处。但是可以在任何地方使用第二种形式，甚至是在方法调用的内部。

### 5.8.1 可变参数列表

Java5以后提供了变长参数。其实当你指定参数时，编译器实际上会为你去填充数组。你获取的仍旧是一个数组。

使用...表示可变长参数。可变参数列表中可以使用任何类型的参数，包括基本类型。一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数。

如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法可以把它们当作可变参数列表来接受。

将0个参数传递给可变参数列表是可行的。

可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择地将int参数提升为Integer。

可变参数列表会有很多问题，比如下例：

```java
public class OverloadingVarargs {
  static void f(Character... args) {
    System.out.print("first");
    for(Character c : args)
      System.out.print(" " + c);
    System.out.println();
  }
  static void f(Integer... args) {
    System.out.print("second");
    for(Integer i : args)
      System.out.print(" " + i);
    System.out.println();
  }
  static void f(Long... args) {
    System.out.println("third");
  }
  public static void main(String[] args) {
    f('a', 'b', 'c');
    f(1);
    f(2, 1);
    f(0);
    f(0L);
    //! f(); // Won't compile -- ambiguous
  }
}
```

编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。但是在不使用参数调用f()时，编译器就无法知道应该调用哪一个方法了。

应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它。可变参数列表也有很多隐藏的坑，详见《Java那些事》中的讲述。

## 5.9 枚举类型

在Java5中添加enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。

```java
public enum Spiciness {
  NOT, MILD, MEDIUM, HOT, FLAMING
}
```

为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例：

```java
public class SimpleEnumUse {
  public static void main(String[] args) {
    Spiciness howHot = Spiciness.MEDIUM;
    System.out.println(howHot);
  }
}
```

在你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toStriug()方法，以便可以很方便地显示某个enum实例的名字，编译器还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组。







