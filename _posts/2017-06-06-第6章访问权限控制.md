---
layout: post
title:  "第6章 访问权限控制"
date:   2017-06-06 15:14:54
categories: 《Java编程思想》
tags: Java 访问权限
author: M.renard
mathjax: false
---

* content
{:toc}

访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限（没有关键词）和private。





## 6.1 包：库单元

包内包含有一组类，它们在单一的名字空间之下被组织在了一起。如果你想要导入单个的类，可以在import语句中命名该类。

当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元)。每个编译单元都必须有一个后缀名Java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同。每个编译单元只能有一个public类，否则编译器就不会接受。

### 6.1.1 代码组织

Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的査找、装载和解释。

类库实际上是一组类文件。其中每个文件都有一个public类，以及任意数量的非public类。如果希望这些构件从属于同一个群组，就可以使用关键字package。package语句必须是文件中除注释以外的第一句程序代码。在文件起始处写。

**Java包的命名规则全部使用小写字母，包括中间的字也是如此。**

### 6.1.2 创建独一无二的包名

ava解释器的运行过程如下：首先，找出环境变量CLASSPATH。CLASSPATH包含一个或多个目录，用作査找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH根中产生一个路径名称。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中査找与你所要创建的类名称相关的.class文件。

## 6.2 Java访问权限修饰词

public、protected和private这几个Java访问权限修饰词在使用时，是置于类中每个成员的定义之前的。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。如果不提供任何访问权限修饰词，则意味着它是“包访问权限”。

### 6.2.1 包访问权限

取得对某成员的访问权的途径是：

1. 使该成员成为public。
2. 通过不加访问权限修饰词并将其他类放置于同一个包内的方式给成员陚予包访问权。于是包内的其他类也就可以访问该成员了。
3. 继承而来的类既可以访问public成员也可以访问protected成员。只有在两个类都处于同一个包内时，它才可以访问包访问权限的成员。
4. 提供访问器（accessor)和变异器（mutator)方法（也称作get/set方法），以读取和改变数值。对OOP而言，这是最优雅的方式，而且这也是JavaBeans的基本原理。

>public：接口访问权限
>
>>使用关键字public,就意味着public之后紧跟着的成员声明自己对每个人都是可用的。
>
>private：你无法访问
>
>>关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。
>
>protected：继承访问权限
>
>>同包的以及继承的子类可以访问这个成员。

## 6.3 类的访问权限

在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。

然而，这里还有一些额外的限制：

1. 每个编译单元（文件）都只能有一个public类。
2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。
3. 编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。只需将关键字public从类中拿掉，这个类就拥有了包访问权限。

注意，类既不可以是private的也不可以是protected的。*（一个内部类可以是private或是protected的，但那是一个特例。）*对于类的访问权限，仅有两个选择：包访问权限或public。如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private,从而阻止任何人创建该类的对象，但是有一个例外，就是你在该类的static成员内部可以创建。例如：

```java
public class Singleton {
    private Singleton(){}
    private static Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

以上为单例模式。
如果没有明确地至少创建一个构造器的话，就会帮你创建一个默认构造器（不带有任何参数的构造器）。如果我们自己编写了默认的构造器，那么就不会自动创建它了。如果把该构造器指定为private,那么就谁也无法创建该类的对象了。

如果没能为类访问权限指定一个访问修饰符，它就会默认得到包访问权限。这就意味着该类的对象可以由包内任何其他类来创建，但在包外则是不行的。然而，如果该类的某个static成员是public的话，则仍旧可以调用该static成员。

























